# テスト仕様書：LangGraph搭載 自律型リサーチエージェント

## 1. ドキュメント情報

- **文書名**: テスト仕様書
- **バージョン**: 1.1
- **作成日**: 2024-12-27
- **最終更新日**: 2025-02-01
- **対象システム**: LangGraph搭載 自律型リサーチエージェント
- **参照文書**: 要求定義書、基本設計書、詳細設計書、API仕様書

---

## 2. テスト概要

### 2.1 テスト目的

本システムの品質を保証するため、主要な機能についてテストを実施します。

### 2.2 テスト範囲

- **ユニットテスト**: 各ノード、ツール、データモデルの個別テスト
- **統合テスト**: グラフ全体の実行フローテスト
- **APIテスト**: REST APIエンドポイントのテスト

### 2.3 テスト環境

- **Python**: 3.10以上
- **テストフレームワーク**: pytest
- **モック**: unittest.mock, pytest-mock
- **カバレッジ**: pytest-cov

---

## 3. ユニットテスト

### 3.1 データモデルテスト

#### TC-DM-001: ResearchPlanの作成とバリデーション

**目的**: ResearchPlanモデルが正しく作成され、バリデーションが機能することを確認

**前提条件**: 
- Pydantic 2.0以上がインストールされている

**テスト手順**:
1. 有効なデータでResearchPlanを作成
2. 無効なデータ（空のtheme）でResearchPlanを作成を試行
3. バリデーションエラーが発生することを確認

**期待結果**:
- 有効なデータでは正常に作成される
- 無効なデータではValidationErrorが発生する

**テストコード例**:
```python
import pytest
from pydantic import ValidationError
from src.schemas.data_models import ResearchPlan

def test_research_plan_creation():
    """有効なResearchPlanを作成"""
    plan = ResearchPlan(
        theme="テストテーマ",
        investigation_points=["観点1", "観点2"],
        search_queries=["クエリ1", "クエリ2"],
        plan_text="計画テキスト"
    )
    assert plan.theme == "テストテーマ"
    assert len(plan.investigation_points) == 2

def test_research_plan_validation_error():
    """無効なデータでバリデーションエラー"""
    with pytest.raises(ValidationError):
        ResearchPlan(
            theme="",  # 空文字列は無効
            investigation_points=[],
            search_queries=[],
            plan_text=""
        )
```

#### TC-DM-002: SearchResultの作成とバリデーション

**目的**: SearchResultモデルが正しく作成され、URLバリデーションが機能することを確認

**テスト手順**:
1. 有効なデータでSearchResultを作成
2. 無効なURLでSearchResultを作成を試行
3. バリデーションエラーが発生することを確認

**期待結果**:
- 有効なデータでは正常に作成される
- 無効なURLではValidationErrorが発生する

**テストコード例**:
```python
from src.schemas.data_models import SearchResult

def test_search_result_creation():
    """有効なSearchResultを作成"""
    result = SearchResult(
        title="テストタイトル",
        summary="テスト要約",
        source="tavily",
        url="https://example.com"
    )
    assert result.title == "テストタイトル"
    assert result.source == "tavily"

def test_search_result_invalid_url():
    """無効なURLでバリデーションエラー"""
    with pytest.raises(ValidationError):
        SearchResult(
            title="テスト",
            summary="テスト",
            source="tavily",
            url="invalid-url"  # HTTP/HTTPS形式ではない
        )
```

---

### 3.2 Supervisorノードテスト

#### TC-SV-001: 計画生成機能

**目的**: Supervisorノードが調査計画を正しく生成することを確認

**前提条件**:
- LLMのモックが設定されている

**テスト手順**:
1. 初期ステート（task_plan=None）を準備
2. supervisor_nodeを実行
3. task_planが生成されることを確認

**期待結果**:
- task_planがNoneからResearchPlanオブジェクトに更新される
- next_actionが設定される

**テストコード例**:
```python
from unittest.mock import Mock, patch
from src.nodes.supervisor import supervisor_node
from src.graph.state import ResearchState
from langchain_core.messages import HumanMessage

def test_supervisor_generates_plan(mocker):
    """Supervisorが計画を生成"""
    # LLMのモック
    mock_llm = Mock()
    mock_llm.invoke.return_value.content = '{"plan": {"theme": "テスト", ...}}'
    
    state: ResearchState = {
        "messages": [HumanMessage(content="テストテーマ")],
        "task_plan": None,
        "research_data": [],
        "current_draft": None,
        "feedback": None,
        "iteration_count": 0,
        "next_action": "research",
        "human_input_required": False,
        "human_input": None
    }
    
    with patch('src.nodes.supervisor.ChatOpenAI', return_value=mock_llm):
        result = supervisor_node(state)
    
    assert result["task_plan"] is not None
    assert result["next_action"] in ["research", "write", "end"]
```

#### TC-SV-002: ルーティング決定機能

**目的**: Supervisorノードが適切なルーティング決定を行うことを確認

**テスト手順**:
1. 十分なデータが集まった状態のステートを準備
2. supervisor_nodeを実行
3. next_actionが"write"になることを確認

**期待結果**:
- データが十分な場合、next_actionが"write"になる

**テストコード例**:
```python
def test_supervisor_routes_to_write():
    """十分なデータがある場合、writeにルーティング"""
    state: ResearchState = {
        "messages": [HumanMessage(content="テストテーマ")],
        "task_plan": ResearchPlan(...),  # 既存の計画
        "research_data": [SearchResult(...)] * 10,  # 十分なデータ
        "current_draft": None,
        "feedback": None,
        "iteration_count": 1,
        "next_action": "research",
        "human_input_required": False,
        "human_input": None
    }
    
    result = supervisor_node(state)
    assert result["next_action"] == "write"
```

---

### 3.3 Researcherノードテスト

#### TC-RS-001: 検索実行機能

**目的**: Researcherノードが検索を実行し、結果を追加することを確認

**前提条件**:
- Tavily検索ツールのモックが設定されている

**テスト手順**:
1. task_planに検索クエリを含むステートを準備
2. researcher_nodeを実行
3. research_dataに結果が追加されることを確認

**期待結果**:
- 検索が実行される
- research_dataに新しい結果が追加される
- iteration_countがインクリメントされる

**テストコード例**:
```python
from unittest.mock import Mock, patch
from src.nodes.researcher import researcher_node

def test_researcher_executes_search(mocker):
    """Researcherが検索を実行"""
    mock_search_tool = Mock()
    mock_search_tool.invoke.return_value = [
        {
            "title": "テスト結果",
            "content": "テスト要約",
            "url": "https://example.com"
        }
    ]
    
    state: ResearchState = {
        "messages": [],
        "task_plan": ResearchPlan(
            theme="テスト",
            search_queries=["テストクエリ"],
            ...
        ),
        "research_data": [],
        "current_draft": None,
        "feedback": None,
        "iteration_count": 0,
        "next_action": "research",
        "human_input_required": False,
        "human_input": None
    }
    
    with patch('src.nodes.researcher.tavily_search_tool', mock_search_tool):
        result = researcher_node(state)
    
    assert len(result["research_data"]) > 0
    assert result["iteration_count"] == 1
```

#### TC-RS-002: 重複除去機能

**目的**: Researcherノードが重複URLを除去することを確認

**テスト手順**:
1. 既存のresearch_dataにURLを含むステートを準備
2. 同じURLを含む検索結果を返すモックを設定
3. researcher_nodeを実行
4. 重複が除去されることを確認

**期待結果**:
- 既存のURLと重複する結果は追加されない

**テストコード例**:
```python
def test_researcher_removes_duplicates():
    """重複URLを除去"""
    existing_result = SearchResult(
        title="既存",
        summary="既存の要約",
        source="tavily",
        url="https://example.com"
    )
    
    state: ResearchState = {
        "research_data": [existing_result],
        ...
    }
    
    # 同じURLを含む検索結果を返すモック
    mock_search_tool.invoke.return_value = [
        {"url": "https://example.com", ...}  # 既存と同じURL
    ]
    
    result = researcher_node(state)
    assert len(result["research_data"]) == 1  # 重複は追加されない
```

---

### 3.4 Writerノードテスト

#### TC-WR-001: ドラフト生成機能

**目的**: Writerノードがレポートドラフトを生成することを確認

**前提条件**:
- LLMのモックが設定されている

**テスト手順**:
1. research_dataを含むステートを準備
2. writer_nodeを実行
3. current_draftが生成されることを確認

**期待結果**:
- current_draftがNoneから文字列に更新される
- マークダウン形式である

**テストコード例**:
```python
from src.nodes.writer import writer_node

def test_writer_generates_draft(mocker):
    """Writerがドラフトを生成"""
    mock_llm = Mock()
    mock_llm.invoke.return_value.content = "# テスト\n\n## Summary\n..."
    
    state: ResearchState = {
        "messages": [],
        "task_plan": ResearchPlan(theme="テスト", ...),
        "research_data": [SearchResult(...)],
        "current_draft": None,
        "feedback": None,
        "iteration_count": 0,
        "next_action": "write",
        "human_input_required": False,
        "human_input": None
    }
    
    with patch('src.nodes.writer.ChatOpenAI', return_value=mock_llm):
        result = writer_node(state)
    
    assert result["current_draft"] is not None
    assert len(result["current_draft"]) > 0
    assert "#" in result["current_draft"]  # マークダウン形式
```

---

### 3.5 Reviewerノードテスト

#### TC-RV-001: ドラフト評価機能

**目的**: Reviewerノードがドラフトを評価し、フィードバックを生成することを確認

**前提条件**:
- LLMのモックが設定されている

**テスト手順**:
1. current_draftを含むステートを準備
2. reviewer_nodeを実行
3. 評価結果とnext_actionが設定されることを確認

**期待結果**:
- 評価結果が生成される
- approvedがFalseの場合、feedbackが設定される
- next_actionが適切に設定される

**テストコード例**:
```python
from src.nodes.reviewer import reviewer_node

def test_reviewer_evaluates_draft(mocker):
    """Reviewerがドラフトを評価"""
    mock_llm = Mock()
    mock_llm.invoke.return_value.content = '{"approved": false, "feedback": "改善が必要", ...}'
    
    state: ResearchState = {
        "messages": [],
        "task_plan": ResearchPlan(...),
        "research_data": [SearchResult(...)],
        "current_draft": "# テスト\n\n内容",
        "feedback": None,
        "iteration_count": 1,
        "next_action": "review",
        "human_input_required": False,
        "human_input": None
    }
    
    with patch('src.nodes.reviewer.ChatOpenAI', return_value=mock_llm):
        result = reviewer_node(state)
    
    assert result["feedback"] is not None
    assert result["next_action"] in ["research", "write", "end"]
```

#### TC-RV-002: 承認時の終了判定

**目的**: Reviewerがドラフトを承認した場合、next_actionが"end"になることを確認

**テスト手順**:
1. 承認されるドラフトを含むステートを準備
2. reviewer_nodeを実行
3. next_actionが"end"になることを確認

**期待結果**:
- approvedがTrueの場合、next_actionが"end"になる
- feedbackがNoneになる

**テストコード例**:
```python
def test_reviewer_approves_draft():
    """ドラフトが承認された場合、終了"""
    mock_llm.invoke.return_value.content = '{"approved": true, ...}'
    
    result = reviewer_node(state)
    assert result["next_action"] == "end"
    assert result["feedback"] is None
```

---

### 3.6 ツールテスト

#### TC-TL-001: Tavily検索ツール

**目的**: Tavily検索ツールが正しく動作することを確認

**前提条件**:
- Tavily APIのモックが設定されている

**テスト手順**:
1. tavily_search_toolを呼び出し
2. 検索結果が返されることを確認

**期待結果**:
- 検索結果のリストが返される
- 各結果にtitle、url、contentが含まれる

**テストコード例**:
```python
from src.tools.search_tool import tavily_search_tool

def test_tavily_search_tool(mocker):
    """Tavily検索ツールの動作確認"""
    mock_tavily = Mock()
    mock_tavily.invoke.return_value = [
        {"title": "テスト", "url": "https://example.com", "content": "..."}
    ]
    
    with patch('src.tools.search_tool.TavilySearchResults', return_value=mock_tavily):
        results = tavily_search_tool("テストクエリ")
    
    assert len(results) > 0
    assert "title" in results[0]
```

---

## 4. 統合テスト

### 4.1 グラフ実行フローテスト

#### TC-IT-001: 基本的なリサーチフロー

**目的**: グラフ全体が正しく実行され、レポートが生成されることを確認

**前提条件**:
- すべてのノードとツールのモックが設定されている

**テスト手順**:
1. 初期ステートを準備
2. グラフを実行
3. 最終的にcurrent_draftが生成されることを確認

**期待結果**:
- グラフが正常に実行される
- すべてのノードが実行される
- 最終的にcurrent_draftが生成される

**テストコード例**:
```python
from src.graph.graph_builder import build_graph
from langchain_core.messages import HumanMessage

def test_full_research_flow(mocker):
    """完全なリサーチフローのテスト"""
    # すべてのモックを設定
    mock_llm = Mock()
    mock_search_tool = Mock()
    # ... その他のモック
    
    initial_state: ResearchState = {
        "messages": [HumanMessage(content="LangGraphについて調査してください")],
        "task_plan": None,
        "research_data": [],
        "current_draft": None,
        "feedback": None,
        "iteration_count": 0,
        "next_action": "research",
        "human_input_required": False,
        "human_input": None
    }
    
    graph = build_graph()
    
    with patch('...', ...):  # すべてのモックを適用
        result = graph.invoke(initial_state)
    
    assert result["current_draft"] is not None
    assert len(result["research_data"]) > 0
```

#### TC-IT-002: 最大イテレーション制御

**目的**: 最大イテレーション数に達した場合、処理が終了することを確認

**テスト手順**:
1. iteration_countが最大値に近いステートを準備
2. グラフを実行
3. 最大イテレーションに達した場合、終了することを確認

**期待結果**:
- iteration_countがMAX_ITERATIONSに達すると終了する
- next_actionが"end"になる

**テストコード例**:
```python
def test_max_iterations():
    """最大イテレーションで終了"""
    state: ResearchState = {
        ...
        "iteration_count": MAX_ITERATIONS - 1,
        ...
    }
    
    result = graph.invoke(state)
    assert result["next_action"] == "end"
```

---

### 4.2 エラーハンドリングテスト

#### TC-IT-003: 検索エラー時の処理

**目的**: 検索エラーが発生した場合、処理が継続することを確認

**テスト手順**:
1. 検索ツールがエラーを返すように設定
2. グラフを実行
3. エラーが記録され、処理が継続することを確認

**期待結果**:
- エラーがメッセージに記録される
- 処理が継続される（クラッシュしない）

**テストコード例**:
```python
def test_search_error_handling():
    """検索エラー時の処理"""
    mock_search_tool.invoke.side_effect = Exception("Search error")
    
    result = graph.invoke(state)
    
    # エラーメッセージが記録されている
    error_messages = [m for m in result["messages"] if "error" in m.content.lower()]
    assert len(error_messages) > 0
```

---

## 5. APIテスト

### 5.1 リサーチ開始API

#### TC-API-001: POST /research

**目的**: リサーチ開始APIが正しく動作することを確認

**テスト手順**:
1. 有効なリクエストを送信
2. レスポンスを確認

**期待結果**:
- ステータスコード: 201
- research_idが返される
- statusが"started"になる

**テストコード例**:
```python
import pytest
from fastapi.testclient import TestClient
from src.api.main import app

client = TestClient(app)

def test_create_research():
    """リサーチ開始APIのテスト"""
    response = client.post(
        "/research",
        json={
            "theme": "テストテーマ",
            "max_iterations": 5
        }
    )
    
    assert response.status_code == 201
    data = response.json()
    assert "research_id" in data
    assert data["status"] == "started"
```

#### TC-API-002: POST /research (バリデーションエラー)

**目的**: 無効なリクエストでバリデーションエラーが返されることを確認

**テスト手順**:
1. 無効なリクエスト（themeが空）を送信
2. レスポンスを確認

**期待結果**:
- ステータスコード: 400
- エラーメッセージが返される

**テストコード例**:
```python
def test_create_research_validation_error():
    """バリデーションエラーのテスト"""
    response = client.post(
        "/research",
        json={
            "theme": "",  # 無効
            "max_iterations": 5
        }
    )
    
    assert response.status_code == 400
    assert "error" in response.json()
```

---

### 5.2 リサーチ結果取得API

#### TC-API-003: GET /research/{research_id}

**目的**: リサーチ結果取得APIが正しく動作することを確認

**テスト手順**:
1. リサーチを開始
2. 完了を待つ（またはモックで完了状態にする）
3. 結果を取得

**期待結果**:
- ステータスコード: 200
- reportが含まれる
- draftとsourcesが含まれる

**テストコード例**:
```python
def test_get_research_result():
    """リサーチ結果取得APIのテスト"""
    # リサーチを開始
    create_response = client.post("/research", json={"theme": "テスト"})
    research_id = create_response.json()["research_id"]
    
    # 結果を取得（モックで完了状態にする）
    response = client.get(f"/research/{research_id}")
    
    assert response.status_code == 200
    data = response.json()
    assert "report" in data
    assert "draft" in data["report"]
```

#### TC-API-004: GET /research/{research_id} (存在しないID)

**目的**: 存在しないリサーチIDで404が返されることを確認

**テスト手順**:
1. 存在しないresearch_idでリクエスト
2. レスポンスを確認

**期待結果**:
- ステータスコード: 404
- エラーメッセージが返される

**テストコード例**:
```python
def test_get_research_not_found():
    """存在しないリサーチIDのテスト"""
    response = client.get("/research/00000000-0000-0000-0000-000000000000")
    
    assert response.status_code == 404
    assert "error" in response.json()
```

---

### 5.3 状態取得API

#### TC-API-005: GET /research/{research_id}/status

**目的**: 状態取得APIが正しく動作することを確認

**テスト手順**:
1. リサーチを開始
2. 状態を取得

**期待結果**:
- ステータスコード: 200
- statusとprogressが含まれる

**テストコード例**:
```python
def test_get_research_status():
    """状態取得APIのテスト"""
    create_response = client.post("/research", json={"theme": "テスト"})
    research_id = create_response.json()["research_id"]
    
    response = client.get(f"/research/{research_id}/status")
    
    assert response.status_code == 200
    data = response.json()
    assert "status" in data
    assert "progress" in data
```

---

### 5.4 ヘルスチェックAPI

#### TC-API-006: GET /health

**目的**: ヘルスチェックAPIが正しく動作することを確認

**テスト手順**:
1. /healthエンドポイントにリクエスト
2. レスポンスを確認

**期待結果**:
- ステータスコード: 200
- statusが"healthy"になる

**テストコード例**:
```python
def test_health_check():
    """ヘルスチェックAPIのテスト"""
    response = client.get("/health")
    
    assert response.status_code == 200
    data = response.json()
    assert data["status"] == "healthy"
```

---

## 6. テスト実行方法

### 6.1 テストの実行

```bash
# すべてのテストを実行
pytest

# 特定のテストファイルを実行
pytest tests/test_nodes.py

# 特定のテストケースを実行
pytest tests/test_nodes.py::test_supervisor_generates_plan

# カバレッジを取得
pytest --cov=src --cov-report=html
```

### 6.2 テスト環境のセットアップ

```bash
# 依存関係のインストール
pip install -r requirements.txt
pip install pytest pytest-cov pytest-mock

# 環境変数の設定
export OPENAI_API_KEY="test-key"
export TAVILY_API_KEY="test-key"
```

---

## 7. テストカバレッジ目標

| カテゴリ | 目標カバレッジ |
|---------|--------------|
| データモデル | 90%以上 |
| ノード関数 | 80%以上 |
| ツール関数 | 80%以上 |
| APIエンドポイント | 70%以上 |
| 全体 | 75%以上 |

---

## 8. テストデータ

### 8.1 モックデータ

テストで使用するモックデータの例：

```python
MOCK_RESEARCH_PLAN = ResearchPlan(
    theme="テストテーマ",
    investigation_points=["観点1", "観点2"],
    search_queries=["クエリ1", "クエリ2"],
    plan_text="テスト計画"
)

MOCK_SEARCH_RESULT = SearchResult(
    title="テスト結果",
    summary="テスト要約",
    source="tavily",
    url="https://example.com",
    relevance_score=0.9
)

MOCK_LLM_RESPONSE = {
    "plan": {
        "theme": "テスト",
        "investigation_points": ["観点1"],
        "search_queries": ["クエリ1"],
        "plan_text": "計画"
    },
    "next_action": "research",
    "reasoning": "テスト理由"
}
```

---

## 9. 変更履歴

| バージョン | 日付 | 変更内容 |
|-----------|------|---------|
| 1.0 | 2024-12-27 | 初版作成 |
| 1.1 | 2025-02-01 | ドキュメント情報・変更履歴更新 |

---

## 付録A: テストチェックリスト

### ユニットテスト
- [ ] ResearchPlanの作成とバリデーション
- [ ] SearchResultの作成とバリデーション
- [ ] Supervisorノードの計画生成
- [ ] Supervisorノードのルーティング決定
- [ ] Researcherノードの検索実行
- [ ] Researcherノードの重複除去
- [ ] Writerノードのドラフト生成
- [ ] Reviewerノードの評価機能
- [ ] Tavily検索ツールの動作

### 統合テスト
- [ ] 基本的なリサーチフロー
- [ ] 最大イテレーション制御
- [ ] 検索エラー時の処理

### APIテスト
- [ ] POST /research
- [ ] POST /research (バリデーションエラー)
- [ ] GET /research/{id}
- [ ] GET /research/{id} (404)
- [ ] GET /research/{id}/status
- [ ] GET /health

---

## 付録B: 参考資料

- pytest Documentation
- FastAPI Testing Guide
- unittest.mock Documentation

